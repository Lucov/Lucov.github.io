<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artifacts of Our Slicing</title>
    <link rel="stylesheet" href="scene.css">
    <script src="scene.js" defer></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #text-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            transition: opacity 3s;
            z-index: 10;
        }
        
        .word {
            position: absolute;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            pointer-events: none;
            animation: fade 8s infinite;
        }
        
        @keyframes fade {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.6; }
        }
        
        .phase-shift {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="text-layer">
        <p>click to slice reality<br>
        <span style="font-size: 10px; opacity: 0.5;">720Â° to return home</span></p>
    </div>
    <div class="phase-shift">phase: <span id="phase">seeking unity</span></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const textLayer = document.getElementById('text-layer');
        const phaseElement = document.getElementById('phase');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Words from our conversation
        const words = [
            'thing', 'strange loop', 'spinor', 'unity', 'motion', 'stasis',
            'nested', 'reality', 'illusion', 'tangle', 'spiral', 'emergence',
            'phase shift', 'becoming', 'singularity', 'artifact', 'slice'
        ];
        
        // Strange loops visualization
        let loops = [];
        let rotation = 0;
        let globalPhase = 0;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let clicked = false;
        
        class StrangeLoop {
            constructor(x, y, radius, level) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.level = level;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = (Math.random() - 0.5) * 0.02 / (level + 1);
                this.children = [];
                this.phase = Math.random() * Math.PI * 2;
                this.opacity = 1;
                
                if (level < 3 && Math.random() > 0.3) {
                    const numChildren = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < numChildren; i++) {
                        const childAngle = (Math.PI * 2 / numChildren) * i;
                        const childX = Math.cos(childAngle) * radius * 0.5;
                        const childY = Math.sin(childAngle) * radius * 0.5;
                        this.children.push(new StrangeLoop(childX, childY, radius * 0.4, level + 1));
                    }
                }
            }
            
            update() {
                this.angle += this.speed;
                this.phase += 0.01;
                
                // Spinor-like rotation - needs 720 degrees for full cycle
                const spinorPhase = (rotation % (Math.PI * 4)) / (Math.PI * 4);
                this.opacity = 0.3 + 0.7 * Math.abs(Math.sin(spinorPhase * Math.PI));
                
                this.children.forEach(child => child.update());
            }
            
            draw(parentX = 0, parentY = 0, parentAngle = 0) {
                const x = parentX + this.x * Math.cos(parentAngle) - this.y * Math.sin(parentAngle);
                const y = parentY + this.x * Math.sin(parentAngle) + this.y * Math.cos(parentAngle);
                const currentAngle = parentAngle + this.angle;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(currentAngle);
                
                // Draw the loop
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.3})`;
                ctx.lineWidth = 1 / (this.level + 1);
                ctx.beginPath();
                
                // Create a strange loop shape
                for (let i = 0; i < Math.PI * 2; i += 0.1) {
                    const r = this.radius * (1 + 0.2 * Math.sin(i * 3 + this.phase));
                    const px = Math.cos(i) * r;
                    const py = Math.sin(i) * r;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
                
                // Draw children
                this.children.forEach(child => {
                    child.draw(x, y, currentAngle);
                });
            }
        }
        
        // Initialize loops
        function createLoops() {
            loops = [];
            const numLoops = 5;
            for (let i = 0; i < numLoops; i++) {
                const angle = (Math.PI * 2 / numLoops) * i;
                const x = Math.cos(angle) * 100;
                const y = Math.sin(angle) * 100;
                loops.push(new StrangeLoop(x, y, 50, 0));
            }
        }
        
        createLoops();
        
        // Mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        canvas.addEventListener('click', (e) => {
            clicked = true;
            textLayer.style.opacity = '0';
            
            // Create floating words at click position
            const word = words[Math.floor(Math.random() * words.length)];
            const wordElement = document.createElement('div');
            wordElement.className = 'word';
            wordElement.textContent = word;
            wordElement.style.left = e.clientX + 'px';
            wordElement.style.top = e.clientY + 'px';
            wordElement.style.animationDelay = Math.random() * 2 + 's';
            document.body.appendChild(wordElement);
            
            setTimeout(() => wordElement.remove(), 8000);
            
            // Add new loop at click position
            if (loops.length < 20) {
                loops.push(new StrangeLoop(
                    e.clientX - canvas.width / 2,
                    e.clientY - canvas.height / 2,
                    30 + Math.random() * 40,
                    0
                ));
            }
        });
        
        // Animation loop
        function animate() {
            // Fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update rotation (spinor-like 720-degree cycle)
            rotation += 0.005;
            globalPhase += 0.01;
            
            // Update phase display
            const phaseIndex = Math.floor((rotation % (Math.PI * 4)) / (Math.PI * 4) * 4);
            const phases = ['seeking unity', 'splitting wholeness', 'tangling threads', 'approaching return'];
            phaseElement.textContent = phases[phaseIndex];
            
            // Center the coordinate system
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            
            // Draw connections between loops (the tangle)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 0.5;
            loops.forEach((loop, i) => {
                loops.forEach((other, j) => {
                    if (i < j) {
                        const dist = Math.sqrt(
                            Math.pow(loop.x - other.x, 2) + 
                            Math.pow(loop.y - other.y, 2)
                        );
                        if (dist < 200) {
                            ctx.beginPath();
                            ctx.moveTo(loop.x, loop.y);
                            ctx.lineTo(other.x, other.y);
                            ctx.stroke();
                        }
                    }
                });
            });
            
            // Update and draw loops
            loops.forEach(loop => {
                loop.update();
                loop.draw();
            });
            
            // Draw central singularity
            const singularitySize = 5 + Math.sin(globalPhase) * 2;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, 0, singularitySize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>